[
{
	"uri": "https://www.continuouscoding.org/",
	"title": "",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/about/",
	"title": "What is Continuous Coding?",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Continuous Coding - helping to increase the feedback loop during development for quicker development with less bugs.",
	"content": "Continuous Coding is about the software development practices needed to keep the feedback loop short, the project on target, and the marathon endurance to deliver changes faster than the competition.\nInspired by a conversation in the extreme programming email group ContinuosCoding.org aims to inspire developers to implement the practices needed to write code which has few bugs, is on time, and easy to change.\nEvidence has proven that companies which are able to implement Continuous Deployment have less bugs and are more competitive than companies which don't. Companies which are able to enable a DevOps culture, report even greater quality of software and services. In order to accomplish a Continuous Deployment a company needs to be able to first implement Continuous Integration.\nIt is the contention of this group that the safest and most efficient way to accomplish Continuous integration is to practice Continuous Coding.\nJFrog wrote in Liquid Software that beyond Continuous Deployments we must be able to also implement Continuous Updates. Updates to devices and machines which the software development team does not have direct control. For this future to become our new reality, Continuos Coding practices are a must, lest we endanger people with the software we write.\nConcepts Continuous Coding is modeled off eXtreme Programming. There are seven high level concepts which all good practices fit in. Some concepts might sound like they don't apply to developers, or only to developers with authority. But that is not the case.\n continuous features continuous planning continuous certification continuous communication continuous cooperation continuous code review continuous refactoring  "
},
{
	"uri": "https://www.continuouscoding.org/tags/agile/",
	"title": "agile",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/bdd/",
	"title": "BDD",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/posts/",
	"title": "Concepts",
	"tags": ["index"],
	"categories": [],
	"series": [],
	"description": "Main Concepts",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/categories/continuous-coding/",
	"title": "continuous coding",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/posts/1_continuous-features/",
	"title": "Continuous Features",
	"tags": ["agile", "LEAN", "SAFe", "Scrum", "Less", "BDD", "DDD", "Feature"],
	"categories": [],
	"series": ["main concepts"],
	"description": "At the highest level, everything worth working on is a feature. Plan them out, have a goal, determine the customer, define the story.",
	"content": "There are numerous ways to define the feedback loop of planning. All of them have the same goal of generating the big picture.\n LEAN Agile Scrum , Kanban, XP SAFe, Less BDD DDD Event Modelling Six Sigma  As a Continuous Coder the how is less important than participating and speaking up if requirements and planning aren't clear. If you don't know why you are working on something, you will be less able to speak up and fix problems that only you are in a position to notice.\nYou may not have the authority, but you do have the responsibility.\nHow do you know which tool is best for the job?   Agile was designed to get small teams to iterate quickly. When is the best time to iterate quickly? When you are searching for marker fit, and seeking a solution which can go viral. This can be a startup, or an established company looking to spread.\n  In contrast, Six Sigma was designed for important critical systems which could cause disaster if they failed. When the company is already established and doing well, you don't want to harm the main source of income.\n  After a company has found a market fit, but before it's fully established there will be a period of chaotic and rapid growth. During this time, LEAN processes will help alleviate pressure while helping to learn which fires to focus on.\n  Like most techniques in Continuous Coding, none of these strategies will be enough on their own. They need to be paired with other techniques that fit the culture of the company best.\n  How does this apply to me as a developer?   Conway's law is most applicable during the feature definition phase of software development. This means that when practicing continuous coding, the language of the organization, and therefore the language of the variables and classes used within your code is going to be highly correlated to how features are organized.\n  For example, if you are working in a LEAN environment, your code will likely be set up as experiments, quick to throw away or be rewritten. If working in an Agile environment your code might be focused around UseCase Classes with the execute() function.\n  When using Domain Driven Design, you will have classes that reference repositories and boundaries.\n  Don't let the language of the domain scare you. They are all techniques with the same goals. Separation of Concerns, a common metaphor, and adaptability to change at the right level of abstraction.\n    "
},
{
	"uri": "https://www.continuouscoding.org/tags/ddd/",
	"title": "DDD",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/feature/",
	"title": "Feature",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/lean/",
	"title": "LEAN",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/less/",
	"title": "Less",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/series/main-concepts/",
	"title": "main concepts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/safe/",
	"title": "SAFe",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/scrum/",
	"title": "Scrum",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/posts/2_continuous-planning/",
	"title": "Continuous Planning",
	"tags": [""],
	"categories": [],
	"series": ["main concepts"],
	"description": "Keep communication open between all stakeholders. Revise and adapt as new information is learned.",
	"content": "Planning is an important aspect of continuous coding. Many have the misconception that if you are working continuously then planning merges into other processes, but this is a mistake.\nThere are a few different common ways to do continuous planning. You can do all or some of this, as needed.\nThere are two scales at which one needs to plan. There is the high level, long term feature plan. This document is not about that. This is about the daily planning that must take place whenever work is to be done.\n Daily Standup Regular retrospective Iteration planning Release planning Raising blockers \u0026ldquo;Cost of Delay\u0026rdquo; prioritization Create small behavioral batch sizes Preparing for future work  How does this apply to me as a developer?  Never start working on code until you have a clear plan of action. Between every Red/Green phase, refactoring isn't just about removing code duplication or fixing variables names. It's a time to plan and think about where the project is headed. Are we moving in the right direction, or is this going to give us problems later on? Every step of the feedback loop is a time to plan and think. The longer we go without feedback, the longer we go without planning. The less we plan, the more mistakes we will make. The more mistakes, the more wasted work. Don't confuse planning with knowing what to do. An important part of any plan is how to respond to feedback, and reduce wasted work by planning for feedback as soon as possible. Escalate issues that will be more costly (time or money) if they are delayed. Prioritize based on optimizing queue throughput.  "
},
{
	"uri": "https://www.continuouscoding.org/tags/assumptions/",
	"title": "assumptions",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/certification/",
	"title": "certification",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/posts/3_continuous-certification/",
	"title": "Continuous Certification",
	"tags": ["certification", "poc", "tracer-bullets", "exams", "assumptions"],
	"categories": [],
	"series": ["main concepts"],
	"description": "Not just for pointless pieces of paper. Validate your expectations. Make your expectations clear. Define your acceptance criteria.",
	"content": "Certification has gotten a bad reputation, but if approached correctly, it's invaluable.\nWhy do we write acceptance tests, and user stories? So we can certify our programs.\nWhy should we take certification exams, so we can validate our skill sets before moving forward.\nKnow what you want to do, and know that you can do it.\nDon't fall victim to imposter syndrome or the Dunning-Kruger Effect.\nHow does this apply to me as a developer?  The first step after knowing the a plan and/or a feature is to verify your assumptions. Certify that you are working on the right thing in the right way. As a developer, this is the time to advocate for Spikes and Proof of Concepts or \u0026ldquo;Tracer bullets\u0026rdquo; Certify that your usage of terms is consistent across the company. In the above example, of Spikes, Tracer Bullets and PoCs, they can all be the same, and they can all be different. Certify with your team how you will be doing these things. Always certify. Take tests to certify your knowledge, communicate to certify your assumptions, work with small focused goals to certify your plans.  "
},
{
	"uri": "https://www.continuouscoding.org/tags/exams/",
	"title": "exams",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/poc/",
	"title": "poc",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/tracer-bullets/",
	"title": "tracer-bullets",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/communication/",
	"title": "communication",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/posts/4_continuous-communication/",
	"title": "Continuous Communication",
	"tags": ["communication", "psychological-safety", "meetings"],
	"categories": [],
	"series": ["main concepts"],
	"description": "How do you communicate? The largest predictive indicator of what makes a successful team is open communication with psychological safety",
	"content": "Topics for Continuous Communication\n Daily scrum blockers and help requests regular statements of mistakes, alternatives or concerns Psychological Safety  How does this apply to me as a developer? Why does one need to continuously communicate? What benefit does that bring to both the developer and the company? Isn't it more efficient and a better use of my time if I complete what I'm working on and not bother others?\nWhat is the secret to effective continuous deployments? Small batch sizes, fast feedback, and quick iterations. How can you work with small batch sizes if you don't communicate about small items of work? How can you get fast feedback if you don't communicate often?\nPeople are another, slightly slower, system which one needs to interact with to release software. After all, the entire purpose of creating software is for people to use. People provide the context for more feedback, helping you build the right thing and not just the right way. This is why the agile manifesto favors people and collaboration over tools and processes.\nBut how can we communicate without slowing down our progress as explained by small teams and the mythical man month? Whenever you encounter some friction, or encounter the unexpected, make all stake holders aware of the new information. Don't be embarrassed, and don't be afraid to speak up about the new challenges. Psychological safety is important to enable members of the team to feel confidant enough to speak up and create awareness. If a member of the team is afraid to speak, afraid they will be blamed or berated for encountering a problem in the system, then the system will continue to deteriorate and will not get better.\nFailure to communicate is a \u0026ldquo;code smell\u0026rdquo; for a team or company. It is what keeps estimates from being off schedule, and coworkers being upset when the estimates are unreliable. If communication was open and free, then the estimates being wrong would have less impact, because each member of the team and the company will have the knowledge and understanding needed to adapt.\n"
},
{
	"uri": "https://www.continuouscoding.org/tags/meetings/",
	"title": "meetings",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/psychological-safety/",
	"title": "psychological-safety",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/posts/5_continuous-cooperation/",
	"title": "Continuous Cooperation",
	"tags": [""],
	"categories": [],
	"series": ["main concepts"],
	"description": "Talk to your team mates. Move the whole team to the goal together. That means everybody, not just other developers.",
	"content": "Most software development teams are actually software development groups. Don't be part of a group, be part of a team.\nWhat does this mean? What's the difference?\nA software development group is a group of people who happen to share the same general environment, but which act independently for their own concerns with their own motivations. For example, a group of people at the airport all want to get onto the same plane, and they each worry about their tickets and belongings. They help the plane leave on time because each of them wants to reach their destination. However, if one person's luggage can't fit, nobody else is concerned. If another person forgot important travel documents, the group will leave them and not be concerned.\nThis is contrast to a team, which all have the same goal and all need to accomplish that goal together. Each member of the team might have a role to play, but if a person is missing, others will step up to make sure the team accomplishes the goal. When a team member is missing, the team is sad but still goes on. When a team goes on a plane, they make sure all the equipment gets on the plane, because if any equipment is missing, the whole team suffers. If any team member misses their documents, another team member will step up and try to help find a solution. And most importantly, the team is ok if other members of the team are \u0026ldquo;sitting on the bench\u0026rdquo; or experiencing slack time, while others are actively engaged in a task.\nHow does this apply to me as a developer?  Be a team member. Help the team focus on one goal at a time. Help limit the work in progress, so the goal of the team is accomplished and the team can be proud of their efforts. Encourage each member of the team to do their best and create safety for them to fail. Let them fail quickly so feedback is quick and progress can be made. Don't think of yourself as a person who is in a group which has a specific skill in a specific language or technology. Instead think of yourself as a member of a team trying to accomplish a specific task, and use your talents, both technical and general, to accomplish that task. Your specific technical skills will help you contribute to the task, but it should not limit the ways you assist the team. Maybe you'll sit this one out and help optimize the code for better readability or testability and performance. Maybe you'll find ways to automate some tedious process the team complains about. What is more important is that you solve team problems as a team member with unique abilities, and not as an individual who just happens to be co-located with another group of people who want to get to the same destination.  "
},
{
	"uri": "https://www.continuouscoding.org/posts/6_continuous-refactoring/",
	"title": "Continuous Refactoring",
	"tags": ["tdd", "refactoring"],
	"categories": [],
	"series": ["main concepts"],
	"description": "Using TDD, focus on the Refactoring step after your tests are passing for safe design and architecture changes.",
	"content": "Continuous Refactoring Continuous refactoring is what we need to do to maintain Continuous Integrations and to make sure our pipelines for Continuous Delivery stay robust and maintain our confidence.\nContinuous refactoring means that you are constantly improving the structure of your code so that the next change is easier to make, and the next developer is realistically confident about the changes they are making.\nWhen does continuous refactoring happen? Continuously! Ha ha, but seriously, when? Continuous refactoring happens between the red and green stages of TDD. TDD? Really? Yes, really. But TDD doesn't work!. Then you are holding it wrong. TDD alone doesn't work. TDD alone isn't enough to get you creating well designed code. TDD however, DOES give you the quickest possible feedback loop for your code and design. It gives you the quickest feedback loop to know what to refactor. There is no faster feedback loop than TDD when developing software, and there is nothing more important for the Continuous Delivery pipeline than a fast feedback loop. TDD does work, but so does any other equally fast feedback loop.\nThe important part here is that you have a test to confirm the expected behavior, you have that test fail to confirm the test doesn't give a false passing, you get that test to pass, and then you use the passing tests to certify that you are changing the structure, but not changing the behavior of your code. This may sound like it only works in certain scenarios, like green field projects or bug fixing, but this works for any code which is being written after a spike or tracer bullet has been written.\nHow does this apply to me as a developer?  This entire section is all about being a developer. The real question is; How does this apply to other team members? For the team leads. Every step in the red/green/refactor cycle should be quick. If it's not quick you don't have a good plan For QA. Get involved with the testing plans early. Prepare the end to end and acceptance tests which the TDD cycle can enhance. This lets the TDD cycle focus on variations that will not be handled by most higher level tests, especially the error path. For everyone on the team. Test first. Know where you are going first. Have your expected outputs before you start \u0026ldquo;work\u0026rdquo;.  "
},
{
	"uri": "https://www.continuouscoding.org/tags/refactoring/",
	"title": "refactoring",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/tdd/",
	"title": "tdd",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/ci/cd/",
	"title": "CI/CD",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/code-reviews/",
	"title": "code reviews",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/posts/7_continuous-code-review/",
	"title": "Continuous Code Review",
	"tags": ["pair programming", "mob programming", "code reviews", "CI/CD"],
	"categories": [],
	"series": ["main concepts"],
	"description": "Use pair or mob programming techniques to increase communication and continuously review the code.",
	"content": "Pair or Mob Programing Mob and Pair programming are great techniques to improve the quality and stability of the code you produce. Programming with extra sets of eyeballs creates three main competitive advantages.\n Both implicit and explicit knowledge is transferred between team members. New skills and team standards can be learned quicker than if studied independently. Sticky or tough issues get resolved more quickly, as answers come from unexpected places. Bad architecture will be spotted and cleaned up sooner because of the multiple perspectives looking at the code as it is created.  The most important aspect of Mob programming is the way the team learns from each other, gets exposed to new ways of solving problems, and exposed to more parts of the system than they would otherwise engage in.\nThe continuous code review to spot \u0026ldquo;problems\u0026rdquo; is the least beneficial aspect. This is because the real value in code reviews is in maintaining consistency across the project.\nWhen pairing or mobbing, that learning and enforced consistency becomes essential to maintaining the flow of the programming experience.\nMany people fear that they would hate to work with multiple people when they are so used to working alone, and to those people I suggest validating your assumptions before coming to a firm conclusion.\nHow does this apply to me as a developer?  Always mob/pair when you can. You want to avoid dead time by waiting for code reviews. Instead advocate for code reviews during the pairing. During the pairing, you will talk about what you are doing, how you are doing it, and why you are doing it. By reviewing the code during the session, you also review the plan.  "
},
{
	"uri": "https://www.continuouscoding.org/tags/mob-programming/",
	"title": "mob programming",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/tags/pair-programming/",
	"title": "pair programming",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/posts/agile/",
	"title": "",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "Continuous Coding with Agile A quick summary of agile inspired by the tweets‍ of Christian Hujer @christianhujer\nNothing is more agile than gaining quick confidence After making a change, you have 90% confidence within 10 seconds, and 100% confidence within 10 minutes that the change can be released, and then you do so. This ability gives you more continuous certification, than any actual certificate. Continuous Coders embrace change, with fast feedback and Continuous everything. XP calls this \u0026ldquo;courage\u0026rdquo;\nYou don't need high level Scrum or SAFe certificates, if you have the technical discipline, and technical practices which enable this kind of confidence. These are known as Software Craft, Clean Code, Extreme Programming, and DevOps.\nAttention to detail and discipline about the craft, which begins with whitespace discipline, proper source code formatting, names that reveal intent, and related code conventions. @unclebobmartin calls this \u0026ldquo;Clean Code\u0026rdquo;. XP calls this \u0026ldquo;Common Coding Standard\u0026rdquo;.\nLearn about Queue theory and the economic principles behind the Cost of Delay and how to make the company you work for the most value possible. Learn how small batch sizes, decentralized decision making, and financial options allows a team to optimize their work in such a way as to produce the greatest amount of throughput with the least amount of utilization needed to accomplish the goals. When utilization is at 100%, the team will be stuck in a traffic jam, unable to be agile or make great progress.\nRigorous coverage and automation of static and dynamic verification of the required behavior and structural quality on development, architecture, and user requirements level.\nTest Automation Pyramid:\n Acceptance Tests for users Integration Tests for architecture Developer (aka Unit) Tests for programmers (By @mikewcohn and @unclebobmartin ) Tailor it. Example: Separate driver test layer for the firmware HAL.  TDD - Test-Driven Development:\n 3 Laws (start with test, no more test than is sufficient to fail, no more prod code than is sufficient to pass) Red-Green-Refactor Cycle TPP - Transformation Priority Premise TCR - test \u0026amp;\u0026amp; commit || revert Code Coverage with 100% line and 100% branch coverage Mutation coverage with 0 surviving mutants BDD: separate test spec and implementation, especially if it's for the user. (By @KentBeck, @unclebobmartin, @WardCunningham, @tastapod, and many others)  Refactor continuously and mercilessly to keep the simple design up. Don't just try to find a way that works. Try to find the best (aka simplest, easiest/cheapest to change in future) way that works. Slow in the short term. Fast in the long term.\nRefactor continuously and mercilessly to keep design smells away.\n Rigidity causes predictable cost aka effort. Fragility causes unpredictable cost aka risk. Immobility/Inseparability makes you and the business cry when you try to reuse. Viscosity just makes you slow.  Static Code Analysis with tools like PC-Lint, CheckStyle, PMD, FindBugs, IntelliJ IDEA Inspections, SonarLint/SonarQube, ESLint, golint, whatever works for your programming language and environment.\nMake sure that all team members are proficient in and have access to all tools, practices, and processes for quality assurance. The easiest way is to use open source, don't create license or political barriers between people and quality.\nThe 4 Rules of Simple Design:\n Reveals Intent No Duplication (DRY) Fewest Number of Elements Passes the Tests (By @KentBeck )  Automate rigorously. Ensure that feedback is\n fast easy to obtain difficult to bypass Fail the build if stuff is even slightly fishy! Your verification should be fast and exhaustive at the same time. When it passes, you should have 100% confidence that your software is releasable. And it should pass within minutes. Use parallelization and good caching to enable such fast builds and tests.  Good Design. SOLID Principles. Applies to Object Oriented and Functional Programming styles\n Single Responsibility: On its level of abstraction, stuff should have only one reason for change. Open/Closed: Implement features by adding new code (modules), not changing existing code. Liskov: Type hierarchies mustn't cause trouble. Interface Segregation: Keep unrelated users out of each other's way. Dependency Inversion: Depend on stable abstractions, not unstable implementations. Also: Avoid cyclic dependencies Colocate cohesive things, don't colocate non-cohesive things Depend in the direction of stability and abstraction. (By @unclebobmartin, LSP by Barbara Liskov, OCP by Bertrand Meyer)  Last but not least, make sure the way to the users is short in time and space. Done should mean no less than \u0026ldquo;in the happy hands of the users\u0026rdquo;. XP called this Continuous Integration, and this is also known as Continuous Release/Delivery/Deployment and DevOps.\nAnd besides providing your stuff to the users it also means communication with, especially listening to, the users. Listening is one of the 4 practices of Extreme Programming. The other 3 are Coding, Testing, and Designing, covered above.\nYou can listen to the words of users directly, but you can also listen to their behavior, using metrics, KPIs, and LEAN practices.\nThanks to @WardCunningham @KentBeck @RonJeffries @unclebobmartin @martinfowler @tastapod @jbrains @tottinge @jwgrenning @pragdave @PragmaticAndy @Grady_Booch @jcoplien etc for these insights. Misquotations and errors are mine. Plus, buy their books, read their blogs, watch their videos.\nAnd as always, things are exaggerated and simplified. There are no absolutes. You'll come up with \u0026ldquo;but you can't verify within 10m whether XYZ works\u0026rdquo;. Is your project that big? What's your excuse for not gaining 100% release confidence within a reasonable time? Do it as fast as you can, and then make it faster.\n"
},
{
	"uri": "https://www.continuouscoding.org/archive/",
	"title": "Archive",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Archive Page",
	"content": "archive page\n"
},
{
	"uri": "https://www.continuouscoding.org/resources/tests/",
	"title": "Continuous Certification Self Assessment tests",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Tests to give you the confidence that you have the skill to implement best practices",
	"content": "\u0026ndash; Before you start trying to implement the skills and practices discussed in this site, try some tests to make sure you fully understand them.\nAlternatively, you can take the tests to help you know what you need to understand.\nEither way, the idea is to validate your assumptions, and get quick feedback on where you are going. Better to take the test and fail quickly, than to implement some ideas and find out it made things worse.\nTests for SOLID   https://www.flexiquiz.com/SC/N/bcbc850d-a6ee-4d76-940a-d016cffac68b\n  (Accepting pull requests for new tests)\n  "
},
{
	"uri": "https://www.continuouscoding.org/resources/blogs/",
	"title": "Continuous reading",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "This is a simple list of blogs and websites which delve deeper into the concepts of Continuous Coding by various other names",
	"content": " Continuous Updates Continuous Delivery Continuous Integration Continuous Testing Continuous Coding Clean Coder Blog - TDD with Uncle Bob Micro skills with Arlo Belshee Marting Fowler Kent Beck James Coplien Pragmatic Programmer Code Complete https://blog.pragmaticengineer.com/ XP Mailling List TDD Mailing List  "
},
{
	"uri": "https://www.continuouscoding.org/resources/papers/",
	"title": "Continuous Research Papers",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Ideas are just opinions until you have data to back them up. Here are links to research papers.",
	"content": " https://github.com/papers-we-love/papers-we-love https://github.com/learn-anything/research-papers  "
},
{
	"uri": "https://www.continuouscoding.org/resources/videos/",
	"title": "Continuous Watching",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Relevant Videos",
	"content": ""
},
{
	"uri": "https://www.continuouscoding.org/resources/",
	"title": "Resources",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]